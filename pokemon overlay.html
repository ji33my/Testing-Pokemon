<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Pokémon Timer</title>
<style>
  body {
    background: transparent;
    color: #FF0000;
    font-family: Arial, sans-serif;
    text-align: center;
    font-size: 48px;
    font-weight: bold;
    -webkit-text-stroke: 2px white;
    text-shadow: 2px 2px 0 #00000033;
  }
  #label {
    font-size: 24px;
    margin-top: 10px;
    font-weight: bold;
    color: #FF0000;
    -webkit-text-stroke: 1px white;
    text-shadow: 1px 1px 0 #00000033;
    line-height: 1.2;
  }
</style>
</head>
<body>
<div id="timer">--:--</div>
<div id="label">
  <div>Time until</div>
  <div>next Pokémon</div>
</div>

<script>
const apiUrl = "https://poketwitch.bframework.de/info/events/last_spawn/?t=1";
let nextSpawn = null;

// Fallback base: 12:04:57 AM EST + (15 min 3 sec intervals)
function getFallbackNextSpawn() {
    const now = new Date();
    const baseTime = new Date(now.toLocaleString("en-US", { timeZone: "America/New_York" }));
    baseTime.setHours(0, 4, 57, 0); // 12:04:57 AM EST

    const interval = 15 * 60 * 1000; // 15m 3s
    const elapsed = now - baseTime;
    const intervalsPassed = Math.ceil(elapsed / interval);

    return new Date(baseTime.getTime() + intervalsPassed * interval);
}

function saveCache(date) {
    try {
        localStorage.setItem("cachedNextSpawn", date.toISOString());
    } catch (e) {
        console.warn("localStorage save failed:", e);
    }
}

function loadCache() {
    try {
        const saved = localStorage.getItem("cachedNextSpawn");
        if (saved) {
            const d = new Date(saved);
            if (!isNaN(d.getTime())) return d;
        }
    } catch (e) {
        console.warn("localStorage load failed:", e);
    }
    return null;
}

// Fetch next spawn from API, cache result
async function fetchNextSpawn() {
    try {
        const response = await fetch(apiUrl, { cache: "no-store" });
        const data = await response.json();

        if (!data.last_spawn_time) throw new Error("Missing last_spawn_time");

        const lastSpawn = new Date(data.last_spawn_time);
        if (isNaN(lastSpawn.getTime())) throw new Error("Invalid date");

        nextSpawn = new Date(lastSpawn.getTime() + 5 * 60 * 1000);
        saveCache(nextSpawn);

    } catch (err) {
        console.warn("API failed:", err);

        const cached = loadCache();
        if (cached) {
            // move forward by interval to avoid sticking in the past
            nextSpawn = new Date(cached.getTime() + (15 * 60 * 1000));
            saveCache(nextSpawn);
        } else {
            nextSpawn = getFallbackNextSpawn();
            saveCache(nextSpawn);
        }
    }
}

// Update timer every second
function updateTimer() {
    if (!nextSpawn) return;

    const now = new Date();
    let diff = nextSpawn - now;

    if (diff <= 0) {
        fetchNextSpawn(); // Always hit API when timer ends
        diff = 0;
    }

    const minutes = String(Math.floor(diff / 60000)).padStart(2, '0');
    const seconds = String(Math.floor((diff % 60000) / 1000)).padStart(2, '0');

    document.getElementById("timer").textContent = `${minutes}:${seconds}`;
}

// Init
(async function () {
    const cached = loadCache();
    if (cached) nextSpawn = cached;

    if (!nextSpawn) {
        await fetchNextSpawn();
    }

    setInterval(updateTimer, 1000);
})();
</script>
</body>
</html>

