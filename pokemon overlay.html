<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Next Pokémon Timer</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    background: transparent;
    overflow: hidden;
    font-family: Arial, Helvetica, sans-serif;
    text-align: center;
  }

  #timer {
    font-size: 96px;
    font-weight: 900;
    color: #cc0000; /* Pokémon red */
    -webkit-text-stroke: 4px white;
    text-shadow:
      -2px -2px 0 #fff,
       2px -2px 0 #fff,
      -2px  2px 0 #fff,
       2px  2px 0 #fff;
    line-height: 1;
  }

  #label1, #label2 {
    font-size: 36px;
    font-weight: 900;
    color: #cc0000;
    -webkit-text-stroke: 2px white;
    text-shadow:
      -1px -1px 0 #fff,
       1px -1px 0 #fff,
      -1px  1px 0 #fff,
       1px  1px 0 #fff;
    line-height: 1.1;
  }
</style>
</head>
<body>

<div id="timer">--:--</div>
<div id="label1">Time until</div>
<div id="label2">next Pokémon</div>

<script>
const API_URL = "https://poketwitch.bframework.de/info/events/last_spawn/?t=1";

// 15 minutes 3 seconds
const INTERVAL_MS = (15 * 60 + 3) * 1000;

// Base fallback: 12:04:57 AM EST (convert to UTC)
const BASE_UTC = Date.UTC(2026, 1, 7, 5, 4, 57); 
// NOTE: Feb = month 1 (0-based), 12:04:57 AM EST = 05:04:57 UTC

let nextSpawnTime = null;

// Load cached next spawn
function loadCache() {
  const cached = localStorage.getItem("nextSpawnTime");
  if (cached) {
    nextSpawnTime = parseInt(cached, 10);
  }
}

// Save cache
function saveCache() {
  if (nextSpawnTime) {
    localStorage.setItem("nextSpawnTime", nextSpawnTime.toString());
  }
}

// Fallback chain generator
function generateFromBase(now) {
  let t = BASE_UTC;
  while (t <= now) {
    t += INTERVAL_MS;
  }
  return t;
}

// Pull API
async function fetchFromAPI() {
  try {
    const res = await fetch(API_URL, { cache: "no-store" });
    const data = await res.json();
    const lastSpawn = new Date(data.last_spawn).getTime();
    const next = lastSpawn + INTERVAL_MS;

    if (!isNaN(next)) {
      nextSpawnTime = next;
      saveCache();
      return true;
    }
  } catch (e) {}
  return false;
}

function formatMMSS(ms) {
  ms = Math.max(0, ms);
  const totalSec = Math.floor(ms / 1000);
  const m = Math.floor(totalSec / 60);
  const s = totalSec % 60;
  return String(m).padStart(2, "0") + ":" + String(s).padStart(2, "0");
}

async function ensureNextSpawn() {
  const now = Date.now();

  // Try API
  const apiOk = await fetchFromAPI();
  if (apiOk) return;

  // Use cache
  if (nextSpawnTime && nextSpawnTime > now) return;

  // Advance cache if expired
  if (nextSpawnTime && nextSpawnTime <= now) {
    while (nextSpawnTime <= now) {
      nextSpawnTime += INTERVAL_MS;
    }
    saveCache();
    return;
  }

  // Final fallback: base
  nextSpawnTime = generateFromBase(now);
  saveCache();
}

async function tick() {
  const now = Date.now();

  if (!nextSpawnTime || now >= nextSpawnTime) {
    await ensureNextSpawn();
  }

  const remaining = nextSpawnTime - now;
  document.getElementById("timer").textContent = formatMMSS(remaining);
}

loadCache();
ensureNextSpawn();
setInterval(tick, 1000);
</script>

</body>
</html>
