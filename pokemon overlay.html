<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Next Pokémon Timer</title>
<style>
   body {
    background: transparent;
    color: #FF0000;
    font-family: Arial, sans-serif;
    text-align: center;
    font-size: 48px;
    font-weight: bold;
    -webkit-text-stroke: 2px white;
    text-shadow: 2px 2px 0 #00000033;
  }

  #label {
    font-size: 24px;
    margin-top: 10px;
    font-weight: bold;
    color: #FF0000;
    -webkit-text-stroke: 1px white;
    text-shadow: 1px 1px 0 #00000033;
    line-height: 1.2;
  }
</style>
</head>
<body>

<div id="timer">--:--</div>
<div id="label">
  <div>Time until</div>
  <div>next Pokémon</div>
</div>

<script>
const API_URL = "https://poketwitch.bframework.de/info/events/last_spawn/?t=1";
const INTERVAL_MS = 15 * 60 * 1000; // 15 minutes flat
const BASE_UTC = Date.UTC(2026, 1, 7, 5, 4, 57); // fallback base

let nextSpawnTime = null;

// Load cached next spawn
function loadCache() {
  const cached = localStorage.getItem("nextSpawnTime");
  if (cached) {
    nextSpawnTime = parseInt(cached, 10);
  }
}

// Save cache
function saveCache() {
  if (nextSpawnTime) {
    localStorage.setItem("nextSpawnTime", nextSpawnTime.toString());
  }
}

// Generate next spawn from base
function generateFromBase(now) {
  let t = BASE_UTC;
  while (t <= now) {
    t += INTERVAL_MS;
  }
  return t;
}

// Fetch API
async function fetchFromAPI() {
  try {
    const res = await fetch(API_URL, { cache: "no-store" });
    const data = await res.json();
    const lastSpawn = new Date(data.event_time).getTime();
    const next = lastSpawn + INTERVAL_MS;

    if (!isNaN(next)) {
      nextSpawnTime = next;
      saveCache();
      return true;
    }
  } catch (e) {
    console.warn("API fetch failed:", e);
  }
  return false;
}

function formatMMSS(ms) {
  ms = Math.max(0, ms);
  const totalSec = Math.floor(ms / 1000);
  const m = Math.floor(totalSec / 60);
  const s = totalSec % 60;
  return String(m).padStart(2, "0") + ":" + String(s).padStart(2, "0");
}

async function ensureNextSpawn() {
  const now = Date.now();

  // 1️⃣ Try API first
  const apiOk = await fetchFromAPI();
  if (apiOk) return;

  // 2️⃣ Use cache if valid
  if (nextSpawnTime && nextSpawnTime > now) return;

  // 3️⃣ Advance stale cache
  if (nextSpawnTime && nextSpawnTime <= now) {
    while (nextSpawnTime <= now) {
      nextSpawnTime += INTERVAL_MS;
    }
    saveCache();
    return;
  }

  // 4️⃣ Fallback to base
  nextSpawnTime = generateFromBase(now);
  saveCache();
}

async function tick() {
  const now = Date.now();

  if (!nextSpawnTime || now >= nextSpawnTime) {
    await ensureNextSpawn();
  }

  const remaining = nextSpawnTime - now;
  document.getElementById("timer").textContent = formatMMSS(remaining);
}

// Init
loadCache();
ensureNextSpawn();
setInterval(tick, 1000);
</script>

</body>
</html>

